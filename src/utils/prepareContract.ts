import { ReactionContract } from "../services/supabaseCollum/reactionContract";
import { calculateSimpleShare } from "../services/simpleShareAlgo";

interface PrepareContractParams {
    videoCreator: any;
    videoReactor: any;
    selectedPlan: string;
    prices: {
        oneTime: number;
        payPerViews: number;
        payPerCpm: number;
    };
}

export const prepareContractData = ({
    videoCreator,
    videoReactor,
    selectedPlan,
    prices
}: PrepareContractParams): ReactionContract => {

    // 1. Determine Pricing Model Type
    let pricingModelType: 1 | 2 | 3 = 1; // Default: One Time
    let pricingValue = 0;

    switch (selectedPlan) {
        case "monthly": // Startet als "Einmalzahlung" im UI (etwas verwirrend benannt, aber wir halten uns an die Logik)
            pricingModelType = 1;
            pricingValue = prices.oneTime;
            break;
        case "yearly": // "PayPer 1000 Views"
            pricingModelType = 2;
            pricingValue = prices.payPerViews;
            break;
        case "lifetime": // "PayPer CPM"
            pricingModelType = 3;
            pricingValue = prices.payPerCpm;
            break;
        default:
            pricingModelType = 1;
            pricingValue = prices.oneTime;
    }


    // 2. Recalculate SimpleShare Metadata
    // We do this here to ensure the contract stores the EXACT snapshot of parameters used at creation time.
    const simpleShareParams = {
        viewsReactor: videoReactor.views || 0,
        viewsCreator: videoCreator.views || 0,
        durationReactorSeconds: videoReactor.duration_seconds || 10,
        durationCreatorSeconds: videoCreator.duration_seconds || 10,
        percentShown: videoReactor.duration_seconds / videoCreator.duration_seconds || 1,
        daysSinceUpload: videoCreator.daysSinceUpload || 0,
    };

    const simpleShareScore = calculateSimpleShare(simpleShareParams);

    // Hardcoded metadata for now, as in previous logic - usually these would come from the algo result or inputs
    const fairshareMetadata = {
        marktmacht_score: 0.5, // Placeholder
        schoepferische_leistung: 0.5, // Placeholder
        parameter_dokumentation_url: "https://simpleshare.com/algo/v1",
    };

    // 3. Extract Channel Names
    // Fallback to "Unknown" if not present in the video objects
    const licensorName = videoCreator.channel_title || videoCreator.snippet?.channelTitle || "Unknown Creator";
    const licenseeName = videoReactor.channel_title || videoReactor.snippet?.channelTitle || "Unknown Reactor";

    // 4. Construct the Contract Object
    const contract: ReactionContract = {
        // ID and Timestamps are usually generated by Supabase or we let Supabase handle default, 
        // but the interface requires them. We might need to omit ID if DB auto-generates.
        // For this utility, we'll assume the caller handles ID generation or we pass undefined and let DB handle it?
        // The interface says `id: string`. If we use uuidv4 here we can import it.
        // Let's assume Supabase generates it and we cast it, OR we generate one.
        // For now, let's omit ID in the return type if possible, but the interface demands it. 
        // We will generate a temporary one or expect the caller to strip it if needed.
        // Actually, let's use a "temp" string or allow Partial in return type.
        // Changing return type to Partial<ReactionContract> or omitting ID would be cleaner, 
        // but to match the requested interface strictly:
        id: crypto.randomUUID(), // Browser native UUID
        created_at: new Date().toISOString(),

        licensor_id: videoCreator.creator_id,
        licensee_id: videoReactor.creator_id,
        licensor_name: licensorName,
        licensee_name: licenseeName,

        original_video_title: videoCreator.title,
        original_video_url: `https://www.youtube.com/watch?v=${videoCreator.id}`,
        original_video_id: videoCreator.id,
        original_video_duration: `${videoCreator.duration_seconds || 0} seconds`,

        pricing_model_type: pricingModelType,
        pricing_value: pricingValue,
        pricing_currency: "EUR",

        fairshare_score: simpleShareScore,
        fairshare_metadata: fairshareMetadata,

        accepted_by_licensor: false,
        accepted_by_licensee: true, // Auto-accept by the one creating it (the reactor usually)
        licensee_accepted_at: new Date().toISOString(),

        contract_version: "1.0",
    };

    return contract;
};
